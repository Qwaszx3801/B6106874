// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/Varissara/app/ent/educationlevel"
	"github.com/Varissara/app/ent/scholarship"
	"github.com/Varissara/app/ent/scholarshiptype"
	"github.com/Varissara/app/ent/semester"
	"github.com/Varissara/app/ent/studyplan"
	"github.com/Varissara/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEducationlevel  = "Educationlevel"
	TypeScholarship     = "Scholarship"
	TypeScholarshiptype = "Scholarshiptype"
	TypeSemester        = "Semester"
	TypeStudyplan       = "Studyplan"
	TypeUser            = "User"
)

// EducationlevelMutation represents an operation that mutate the Educationlevels
// nodes in the graph.
type EducationlevelMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Educationlevelname      *string
	clearedFields            map[string]struct{}
	_EducationlevelID        map[int]struct{}
	removed_EducationlevelID map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Educationlevel, error)
}

var _ ent.Mutation = (*EducationlevelMutation)(nil)

// educationlevelOption allows to manage the mutation configuration using functional options.
type educationlevelOption func(*EducationlevelMutation)

// newEducationlevelMutation creates new mutation for $n.Name.
func newEducationlevelMutation(c config, op Op, opts ...educationlevelOption) *EducationlevelMutation {
	m := &EducationlevelMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationlevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationlevelID sets the id field of the mutation.
func withEducationlevelID(id int) educationlevelOption {
	return func(m *EducationlevelMutation) {
		var (
			err   error
			once  sync.Once
			value *Educationlevel
		)
		m.oldValue = func(ctx context.Context) (*Educationlevel, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Educationlevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationlevel sets the old Educationlevel of the mutation.
func withEducationlevel(node *Educationlevel) educationlevelOption {
	return func(m *EducationlevelMutation) {
		m.oldValue = func(context.Context) (*Educationlevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationlevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationlevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EducationlevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEducationlevelname sets the Educationlevelname field.
func (m *EducationlevelMutation) SetEducationlevelname(s string) {
	m._Educationlevelname = &s
}

// Educationlevelname returns the Educationlevelname value in the mutation.
func (m *EducationlevelMutation) Educationlevelname() (r string, exists bool) {
	v := m._Educationlevelname
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationlevelname returns the old Educationlevelname value of the Educationlevel.
// If the Educationlevel object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EducationlevelMutation) OldEducationlevelname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEducationlevelname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEducationlevelname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationlevelname: %w", err)
	}
	return oldValue.Educationlevelname, nil
}

// ResetEducationlevelname reset all changes of the "Educationlevelname" field.
func (m *EducationlevelMutation) ResetEducationlevelname() {
	m._Educationlevelname = nil
}

// AddEducationlevelIDIDs adds the EducationlevelID edge to Scholarship by ids.
func (m *EducationlevelMutation) AddEducationlevelIDIDs(ids ...int) {
	if m._EducationlevelID == nil {
		m._EducationlevelID = make(map[int]struct{})
	}
	for i := range ids {
		m._EducationlevelID[ids[i]] = struct{}{}
	}
}

// RemoveEducationlevelIDIDs removes the EducationlevelID edge to Scholarship by ids.
func (m *EducationlevelMutation) RemoveEducationlevelIDIDs(ids ...int) {
	if m.removed_EducationlevelID == nil {
		m.removed_EducationlevelID = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_EducationlevelID[ids[i]] = struct{}{}
	}
}

// RemovedEducationlevelID returns the removed ids of EducationlevelID.
func (m *EducationlevelMutation) RemovedEducationlevelIDIDs() (ids []int) {
	for id := range m.removed_EducationlevelID {
		ids = append(ids, id)
	}
	return
}

// EducationlevelIDIDs returns the EducationlevelID ids in the mutation.
func (m *EducationlevelMutation) EducationlevelIDIDs() (ids []int) {
	for id := range m._EducationlevelID {
		ids = append(ids, id)
	}
	return
}

// ResetEducationlevelID reset all changes of the "EducationlevelID" edge.
func (m *EducationlevelMutation) ResetEducationlevelID() {
	m._EducationlevelID = nil
	m.removed_EducationlevelID = nil
}

// Op returns the operation name.
func (m *EducationlevelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Educationlevel).
func (m *EducationlevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EducationlevelMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Educationlevelname != nil {
		fields = append(fields, educationlevel.FieldEducationlevelname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EducationlevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationlevel.FieldEducationlevelname:
		return m.Educationlevelname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EducationlevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationlevel.FieldEducationlevelname:
		return m.OldEducationlevelname(ctx)
	}
	return nil, fmt.Errorf("unknown Educationlevel field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EducationlevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationlevel.FieldEducationlevelname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationlevelname(v)
		return nil
	}
	return fmt.Errorf("unknown Educationlevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EducationlevelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EducationlevelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EducationlevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Educationlevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EducationlevelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EducationlevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationlevelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Educationlevel nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EducationlevelMutation) ResetField(name string) error {
	switch name {
	case educationlevel.FieldEducationlevelname:
		m.ResetEducationlevelname()
		return nil
	}
	return fmt.Errorf("unknown Educationlevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EducationlevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._EducationlevelID != nil {
		edges = append(edges, educationlevel.EdgeEducationlevelID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EducationlevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationlevel.EdgeEducationlevelID:
		ids := make([]ent.Value, 0, len(m._EducationlevelID))
		for id := range m._EducationlevelID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EducationlevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_EducationlevelID != nil {
		edges = append(edges, educationlevel.EdgeEducationlevelID)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EducationlevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case educationlevel.EdgeEducationlevelID:
		ids := make([]ent.Value, 0, len(m.removed_EducationlevelID))
		for id := range m.removed_EducationlevelID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EducationlevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EducationlevelMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EducationlevelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Educationlevel unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EducationlevelMutation) ResetEdge(name string) error {
	switch name {
	case educationlevel.EdgeEducationlevelID:
		m.ResetEducationlevelID()
		return nil
	}
	return fmt.Errorf("unknown Educationlevel edge %s", name)
}

// ScholarshipMutation represents an operation that mutate the Scholarships
// nodes in the graph.
type ScholarshipMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Schlolarshipname         *string
	organization              *string
	clearedFields             map[string]struct{}
	_ScholarshiptypeID        *int
	cleared_ScholarshiptypeID bool
	_EducationlevelID         *int
	cleared_EducationlevelID  bool
	_StudyplanID              *int
	cleared_StudyplanID       bool
	_SemesterID               *int
	cleared_SemesterID        bool
	_UserID                   *int
	cleared_UserID            bool
	done                      bool
	oldValue                  func(context.Context) (*Scholarship, error)
}

var _ ent.Mutation = (*ScholarshipMutation)(nil)

// scholarshipOption allows to manage the mutation configuration using functional options.
type scholarshipOption func(*ScholarshipMutation)

// newScholarshipMutation creates new mutation for $n.Name.
func newScholarshipMutation(c config, op Op, opts ...scholarshipOption) *ScholarshipMutation {
	m := &ScholarshipMutation{
		config:        c,
		op:            op,
		typ:           TypeScholarship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScholarshipID sets the id field of the mutation.
func withScholarshipID(id int) scholarshipOption {
	return func(m *ScholarshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Scholarship
		)
		m.oldValue = func(ctx context.Context) (*Scholarship, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scholarship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScholarship sets the old Scholarship of the mutation.
func withScholarship(node *Scholarship) scholarshipOption {
	return func(m *ScholarshipMutation) {
		m.oldValue = func(context.Context) (*Scholarship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScholarshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScholarshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ScholarshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSchlolarshipname sets the Schlolarshipname field.
func (m *ScholarshipMutation) SetSchlolarshipname(s string) {
	m._Schlolarshipname = &s
}

// Schlolarshipname returns the Schlolarshipname value in the mutation.
func (m *ScholarshipMutation) Schlolarshipname() (r string, exists bool) {
	v := m._Schlolarshipname
	if v == nil {
		return
	}
	return *v, true
}

// OldSchlolarshipname returns the old Schlolarshipname value of the Scholarship.
// If the Scholarship object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScholarshipMutation) OldSchlolarshipname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchlolarshipname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchlolarshipname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchlolarshipname: %w", err)
	}
	return oldValue.Schlolarshipname, nil
}

// ResetSchlolarshipname reset all changes of the "Schlolarshipname" field.
func (m *ScholarshipMutation) ResetSchlolarshipname() {
	m._Schlolarshipname = nil
}

// SetOrganization sets the organization field.
func (m *ScholarshipMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the organization value in the mutation.
func (m *ScholarshipMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old organization value of the Scholarship.
// If the Scholarship object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScholarshipMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrganization is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization reset all changes of the "organization" field.
func (m *ScholarshipMutation) ResetOrganization() {
	m.organization = nil
}

// SetScholarshiptypeIDID sets the ScholarshiptypeID edge to Scholarshiptype by id.
func (m *ScholarshipMutation) SetScholarshiptypeIDID(id int) {
	m._ScholarshiptypeID = &id
}

// ClearScholarshiptypeID clears the ScholarshiptypeID edge to Scholarshiptype.
func (m *ScholarshipMutation) ClearScholarshiptypeID() {
	m.cleared_ScholarshiptypeID = true
}

// ScholarshiptypeIDCleared returns if the edge ScholarshiptypeID was cleared.
func (m *ScholarshipMutation) ScholarshiptypeIDCleared() bool {
	return m.cleared_ScholarshiptypeID
}

// ScholarshiptypeIDID returns the ScholarshiptypeID id in the mutation.
func (m *ScholarshipMutation) ScholarshiptypeIDID() (id int, exists bool) {
	if m._ScholarshiptypeID != nil {
		return *m._ScholarshiptypeID, true
	}
	return
}

// ScholarshiptypeIDIDs returns the ScholarshiptypeID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ScholarshiptypeIDID instead. It exists only for internal usage by the builders.
func (m *ScholarshipMutation) ScholarshiptypeIDIDs() (ids []int) {
	if id := m._ScholarshiptypeID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScholarshiptypeID reset all changes of the "ScholarshiptypeID" edge.
func (m *ScholarshipMutation) ResetScholarshiptypeID() {
	m._ScholarshiptypeID = nil
	m.cleared_ScholarshiptypeID = false
}

// SetEducationlevelIDID sets the EducationlevelID edge to Educationlevel by id.
func (m *ScholarshipMutation) SetEducationlevelIDID(id int) {
	m._EducationlevelID = &id
}

// ClearEducationlevelID clears the EducationlevelID edge to Educationlevel.
func (m *ScholarshipMutation) ClearEducationlevelID() {
	m.cleared_EducationlevelID = true
}

// EducationlevelIDCleared returns if the edge EducationlevelID was cleared.
func (m *ScholarshipMutation) EducationlevelIDCleared() bool {
	return m.cleared_EducationlevelID
}

// EducationlevelIDID returns the EducationlevelID id in the mutation.
func (m *ScholarshipMutation) EducationlevelIDID() (id int, exists bool) {
	if m._EducationlevelID != nil {
		return *m._EducationlevelID, true
	}
	return
}

// EducationlevelIDIDs returns the EducationlevelID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EducationlevelIDID instead. It exists only for internal usage by the builders.
func (m *ScholarshipMutation) EducationlevelIDIDs() (ids []int) {
	if id := m._EducationlevelID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEducationlevelID reset all changes of the "EducationlevelID" edge.
func (m *ScholarshipMutation) ResetEducationlevelID() {
	m._EducationlevelID = nil
	m.cleared_EducationlevelID = false
}

// SetStudyplanIDID sets the StudyplanID edge to Studyplan by id.
func (m *ScholarshipMutation) SetStudyplanIDID(id int) {
	m._StudyplanID = &id
}

// ClearStudyplanID clears the StudyplanID edge to Studyplan.
func (m *ScholarshipMutation) ClearStudyplanID() {
	m.cleared_StudyplanID = true
}

// StudyplanIDCleared returns if the edge StudyplanID was cleared.
func (m *ScholarshipMutation) StudyplanIDCleared() bool {
	return m.cleared_StudyplanID
}

// StudyplanIDID returns the StudyplanID id in the mutation.
func (m *ScholarshipMutation) StudyplanIDID() (id int, exists bool) {
	if m._StudyplanID != nil {
		return *m._StudyplanID, true
	}
	return
}

// StudyplanIDIDs returns the StudyplanID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StudyplanIDID instead. It exists only for internal usage by the builders.
func (m *ScholarshipMutation) StudyplanIDIDs() (ids []int) {
	if id := m._StudyplanID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudyplanID reset all changes of the "StudyplanID" edge.
func (m *ScholarshipMutation) ResetStudyplanID() {
	m._StudyplanID = nil
	m.cleared_StudyplanID = false
}

// SetSemesterIDID sets the SemesterID edge to Semester by id.
func (m *ScholarshipMutation) SetSemesterIDID(id int) {
	m._SemesterID = &id
}

// ClearSemesterID clears the SemesterID edge to Semester.
func (m *ScholarshipMutation) ClearSemesterID() {
	m.cleared_SemesterID = true
}

// SemesterIDCleared returns if the edge SemesterID was cleared.
func (m *ScholarshipMutation) SemesterIDCleared() bool {
	return m.cleared_SemesterID
}

// SemesterIDID returns the SemesterID id in the mutation.
func (m *ScholarshipMutation) SemesterIDID() (id int, exists bool) {
	if m._SemesterID != nil {
		return *m._SemesterID, true
	}
	return
}

// SemesterIDIDs returns the SemesterID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SemesterIDID instead. It exists only for internal usage by the builders.
func (m *ScholarshipMutation) SemesterIDIDs() (ids []int) {
	if id := m._SemesterID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSemesterID reset all changes of the "SemesterID" edge.
func (m *ScholarshipMutation) ResetSemesterID() {
	m._SemesterID = nil
	m.cleared_SemesterID = false
}

// SetUserIDID sets the UserID edge to User by id.
func (m *ScholarshipMutation) SetUserIDID(id int) {
	m._UserID = &id
}

// ClearUserID clears the UserID edge to User.
func (m *ScholarshipMutation) ClearUserID() {
	m.cleared_UserID = true
}

// UserIDCleared returns if the edge UserID was cleared.
func (m *ScholarshipMutation) UserIDCleared() bool {
	return m.cleared_UserID
}

// UserIDID returns the UserID id in the mutation.
func (m *ScholarshipMutation) UserIDID() (id int, exists bool) {
	if m._UserID != nil {
		return *m._UserID, true
	}
	return
}

// UserIDIDs returns the UserID ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserIDID instead. It exists only for internal usage by the builders.
func (m *ScholarshipMutation) UserIDIDs() (ids []int) {
	if id := m._UserID; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserID reset all changes of the "UserID" edge.
func (m *ScholarshipMutation) ResetUserID() {
	m._UserID = nil
	m.cleared_UserID = false
}

// Op returns the operation name.
func (m *ScholarshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scholarship).
func (m *ScholarshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ScholarshipMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Schlolarshipname != nil {
		fields = append(fields, scholarship.FieldSchlolarshipname)
	}
	if m.organization != nil {
		fields = append(fields, scholarship.FieldOrganization)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ScholarshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scholarship.FieldSchlolarshipname:
		return m.Schlolarshipname()
	case scholarship.FieldOrganization:
		return m.Organization()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ScholarshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scholarship.FieldSchlolarshipname:
		return m.OldSchlolarshipname(ctx)
	case scholarship.FieldOrganization:
		return m.OldOrganization(ctx)
	}
	return nil, fmt.Errorf("unknown Scholarship field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScholarshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scholarship.FieldSchlolarshipname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchlolarshipname(v)
		return nil
	case scholarship.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	}
	return fmt.Errorf("unknown Scholarship field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ScholarshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ScholarshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScholarshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scholarship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ScholarshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ScholarshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScholarshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scholarship nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ScholarshipMutation) ResetField(name string) error {
	switch name {
	case scholarship.FieldSchlolarshipname:
		m.ResetSchlolarshipname()
		return nil
	case scholarship.FieldOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Scholarship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ScholarshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._ScholarshiptypeID != nil {
		edges = append(edges, scholarship.EdgeScholarshiptypeID)
	}
	if m._EducationlevelID != nil {
		edges = append(edges, scholarship.EdgeEducationlevelID)
	}
	if m._StudyplanID != nil {
		edges = append(edges, scholarship.EdgeStudyplanID)
	}
	if m._SemesterID != nil {
		edges = append(edges, scholarship.EdgeSemesterID)
	}
	if m._UserID != nil {
		edges = append(edges, scholarship.EdgeUserID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ScholarshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scholarship.EdgeScholarshiptypeID:
		if id := m._ScholarshiptypeID; id != nil {
			return []ent.Value{*id}
		}
	case scholarship.EdgeEducationlevelID:
		if id := m._EducationlevelID; id != nil {
			return []ent.Value{*id}
		}
	case scholarship.EdgeStudyplanID:
		if id := m._StudyplanID; id != nil {
			return []ent.Value{*id}
		}
	case scholarship.EdgeSemesterID:
		if id := m._SemesterID; id != nil {
			return []ent.Value{*id}
		}
	case scholarship.EdgeUserID:
		if id := m._UserID; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ScholarshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ScholarshipMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ScholarshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_ScholarshiptypeID {
		edges = append(edges, scholarship.EdgeScholarshiptypeID)
	}
	if m.cleared_EducationlevelID {
		edges = append(edges, scholarship.EdgeEducationlevelID)
	}
	if m.cleared_StudyplanID {
		edges = append(edges, scholarship.EdgeStudyplanID)
	}
	if m.cleared_SemesterID {
		edges = append(edges, scholarship.EdgeSemesterID)
	}
	if m.cleared_UserID {
		edges = append(edges, scholarship.EdgeUserID)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ScholarshipMutation) EdgeCleared(name string) bool {
	switch name {
	case scholarship.EdgeScholarshiptypeID:
		return m.cleared_ScholarshiptypeID
	case scholarship.EdgeEducationlevelID:
		return m.cleared_EducationlevelID
	case scholarship.EdgeStudyplanID:
		return m.cleared_StudyplanID
	case scholarship.EdgeSemesterID:
		return m.cleared_SemesterID
	case scholarship.EdgeUserID:
		return m.cleared_UserID
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ScholarshipMutation) ClearEdge(name string) error {
	switch name {
	case scholarship.EdgeScholarshiptypeID:
		m.ClearScholarshiptypeID()
		return nil
	case scholarship.EdgeEducationlevelID:
		m.ClearEducationlevelID()
		return nil
	case scholarship.EdgeStudyplanID:
		m.ClearStudyplanID()
		return nil
	case scholarship.EdgeSemesterID:
		m.ClearSemesterID()
		return nil
	case scholarship.EdgeUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Scholarship unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ScholarshipMutation) ResetEdge(name string) error {
	switch name {
	case scholarship.EdgeScholarshiptypeID:
		m.ResetScholarshiptypeID()
		return nil
	case scholarship.EdgeEducationlevelID:
		m.ResetEducationlevelID()
		return nil
	case scholarship.EdgeStudyplanID:
		m.ResetStudyplanID()
		return nil
	case scholarship.EdgeSemesterID:
		m.ResetSemesterID()
		return nil
	case scholarship.EdgeUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Scholarship edge %s", name)
}

// ScholarshiptypeMutation represents an operation that mutate the Scholarshiptypes
// nodes in the graph.
type ScholarshiptypeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Scholarshiptypename      *string
	clearedFields             map[string]struct{}
	_ScholarshiptypeID        map[int]struct{}
	removed_ScholarshiptypeID map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Scholarshiptype, error)
}

var _ ent.Mutation = (*ScholarshiptypeMutation)(nil)

// scholarshiptypeOption allows to manage the mutation configuration using functional options.
type scholarshiptypeOption func(*ScholarshiptypeMutation)

// newScholarshiptypeMutation creates new mutation for $n.Name.
func newScholarshiptypeMutation(c config, op Op, opts ...scholarshiptypeOption) *ScholarshiptypeMutation {
	m := &ScholarshiptypeMutation{
		config:        c,
		op:            op,
		typ:           TypeScholarshiptype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScholarshiptypeID sets the id field of the mutation.
func withScholarshiptypeID(id int) scholarshiptypeOption {
	return func(m *ScholarshiptypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Scholarshiptype
		)
		m.oldValue = func(ctx context.Context) (*Scholarshiptype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scholarshiptype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScholarshiptype sets the old Scholarshiptype of the mutation.
func withScholarshiptype(node *Scholarshiptype) scholarshiptypeOption {
	return func(m *ScholarshiptypeMutation) {
		m.oldValue = func(context.Context) (*Scholarshiptype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScholarshiptypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScholarshiptypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ScholarshiptypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetScholarshiptypename sets the Scholarshiptypename field.
func (m *ScholarshiptypeMutation) SetScholarshiptypename(s string) {
	m._Scholarshiptypename = &s
}

// Scholarshiptypename returns the Scholarshiptypename value in the mutation.
func (m *ScholarshiptypeMutation) Scholarshiptypename() (r string, exists bool) {
	v := m._Scholarshiptypename
	if v == nil {
		return
	}
	return *v, true
}

// OldScholarshiptypename returns the old Scholarshiptypename value of the Scholarshiptype.
// If the Scholarshiptype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ScholarshiptypeMutation) OldScholarshiptypename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScholarshiptypename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScholarshiptypename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScholarshiptypename: %w", err)
	}
	return oldValue.Scholarshiptypename, nil
}

// ResetScholarshiptypename reset all changes of the "Scholarshiptypename" field.
func (m *ScholarshiptypeMutation) ResetScholarshiptypename() {
	m._Scholarshiptypename = nil
}

// AddScholarshiptypeIDIDs adds the ScholarshiptypeID edge to Scholarship by ids.
func (m *ScholarshiptypeMutation) AddScholarshiptypeIDIDs(ids ...int) {
	if m._ScholarshiptypeID == nil {
		m._ScholarshiptypeID = make(map[int]struct{})
	}
	for i := range ids {
		m._ScholarshiptypeID[ids[i]] = struct{}{}
	}
}

// RemoveScholarshiptypeIDIDs removes the ScholarshiptypeID edge to Scholarship by ids.
func (m *ScholarshiptypeMutation) RemoveScholarshiptypeIDIDs(ids ...int) {
	if m.removed_ScholarshiptypeID == nil {
		m.removed_ScholarshiptypeID = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_ScholarshiptypeID[ids[i]] = struct{}{}
	}
}

// RemovedScholarshiptypeID returns the removed ids of ScholarshiptypeID.
func (m *ScholarshiptypeMutation) RemovedScholarshiptypeIDIDs() (ids []int) {
	for id := range m.removed_ScholarshiptypeID {
		ids = append(ids, id)
	}
	return
}

// ScholarshiptypeIDIDs returns the ScholarshiptypeID ids in the mutation.
func (m *ScholarshiptypeMutation) ScholarshiptypeIDIDs() (ids []int) {
	for id := range m._ScholarshiptypeID {
		ids = append(ids, id)
	}
	return
}

// ResetScholarshiptypeID reset all changes of the "ScholarshiptypeID" edge.
func (m *ScholarshiptypeMutation) ResetScholarshiptypeID() {
	m._ScholarshiptypeID = nil
	m.removed_ScholarshiptypeID = nil
}

// Op returns the operation name.
func (m *ScholarshiptypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scholarshiptype).
func (m *ScholarshiptypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ScholarshiptypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Scholarshiptypename != nil {
		fields = append(fields, scholarshiptype.FieldScholarshiptypename)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ScholarshiptypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scholarshiptype.FieldScholarshiptypename:
		return m.Scholarshiptypename()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ScholarshiptypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scholarshiptype.FieldScholarshiptypename:
		return m.OldScholarshiptypename(ctx)
	}
	return nil, fmt.Errorf("unknown Scholarshiptype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScholarshiptypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scholarshiptype.FieldScholarshiptypename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScholarshiptypename(v)
		return nil
	}
	return fmt.Errorf("unknown Scholarshiptype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ScholarshiptypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ScholarshiptypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ScholarshiptypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scholarshiptype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ScholarshiptypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ScholarshiptypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScholarshiptypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scholarshiptype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ScholarshiptypeMutation) ResetField(name string) error {
	switch name {
	case scholarshiptype.FieldScholarshiptypename:
		m.ResetScholarshiptypename()
		return nil
	}
	return fmt.Errorf("unknown Scholarshiptype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ScholarshiptypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ScholarshiptypeID != nil {
		edges = append(edges, scholarshiptype.EdgeScholarshiptypeID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ScholarshiptypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scholarshiptype.EdgeScholarshiptypeID:
		ids := make([]ent.Value, 0, len(m._ScholarshiptypeID))
		for id := range m._ScholarshiptypeID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ScholarshiptypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_ScholarshiptypeID != nil {
		edges = append(edges, scholarshiptype.EdgeScholarshiptypeID)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ScholarshiptypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scholarshiptype.EdgeScholarshiptypeID:
		ids := make([]ent.Value, 0, len(m.removed_ScholarshiptypeID))
		for id := range m.removed_ScholarshiptypeID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ScholarshiptypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ScholarshiptypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ScholarshiptypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Scholarshiptype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ScholarshiptypeMutation) ResetEdge(name string) error {
	switch name {
	case scholarshiptype.EdgeScholarshiptypeID:
		m.ResetScholarshiptypeID()
		return nil
	}
	return fmt.Errorf("unknown Scholarshiptype edge %s", name)
}

// SemesterMutation represents an operation that mutate the Semesters
// nodes in the graph.
type SemesterMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Semestername      *string
	clearedFields      map[string]struct{}
	_SemesterID        map[int]struct{}
	removed_SemesterID map[int]struct{}
	done               bool
	oldValue           func(context.Context) (*Semester, error)
}

var _ ent.Mutation = (*SemesterMutation)(nil)

// semesterOption allows to manage the mutation configuration using functional options.
type semesterOption func(*SemesterMutation)

// newSemesterMutation creates new mutation for $n.Name.
func newSemesterMutation(c config, op Op, opts ...semesterOption) *SemesterMutation {
	m := &SemesterMutation{
		config:        c,
		op:            op,
		typ:           TypeSemester,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSemesterID sets the id field of the mutation.
func withSemesterID(id int) semesterOption {
	return func(m *SemesterMutation) {
		var (
			err   error
			once  sync.Once
			value *Semester
		)
		m.oldValue = func(ctx context.Context) (*Semester, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Semester.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSemester sets the old Semester of the mutation.
func withSemester(node *Semester) semesterOption {
	return func(m *SemesterMutation) {
		m.oldValue = func(context.Context) (*Semester, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SemesterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SemesterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SemesterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSemestername sets the Semestername field.
func (m *SemesterMutation) SetSemestername(s string) {
	m._Semestername = &s
}

// Semestername returns the Semestername value in the mutation.
func (m *SemesterMutation) Semestername() (r string, exists bool) {
	v := m._Semestername
	if v == nil {
		return
	}
	return *v, true
}

// OldSemestername returns the old Semestername value of the Semester.
// If the Semester object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SemesterMutation) OldSemestername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemestername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemestername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemestername: %w", err)
	}
	return oldValue.Semestername, nil
}

// ResetSemestername reset all changes of the "Semestername" field.
func (m *SemesterMutation) ResetSemestername() {
	m._Semestername = nil
}

// AddSemesterIDIDs adds the SemesterID edge to Scholarship by ids.
func (m *SemesterMutation) AddSemesterIDIDs(ids ...int) {
	if m._SemesterID == nil {
		m._SemesterID = make(map[int]struct{})
	}
	for i := range ids {
		m._SemesterID[ids[i]] = struct{}{}
	}
}

// RemoveSemesterIDIDs removes the SemesterID edge to Scholarship by ids.
func (m *SemesterMutation) RemoveSemesterIDIDs(ids ...int) {
	if m.removed_SemesterID == nil {
		m.removed_SemesterID = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_SemesterID[ids[i]] = struct{}{}
	}
}

// RemovedSemesterID returns the removed ids of SemesterID.
func (m *SemesterMutation) RemovedSemesterIDIDs() (ids []int) {
	for id := range m.removed_SemesterID {
		ids = append(ids, id)
	}
	return
}

// SemesterIDIDs returns the SemesterID ids in the mutation.
func (m *SemesterMutation) SemesterIDIDs() (ids []int) {
	for id := range m._SemesterID {
		ids = append(ids, id)
	}
	return
}

// ResetSemesterID reset all changes of the "SemesterID" edge.
func (m *SemesterMutation) ResetSemesterID() {
	m._SemesterID = nil
	m.removed_SemesterID = nil
}

// Op returns the operation name.
func (m *SemesterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Semester).
func (m *SemesterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SemesterMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Semestername != nil {
		fields = append(fields, semester.FieldSemestername)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SemesterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case semester.FieldSemestername:
		return m.Semestername()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SemesterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case semester.FieldSemestername:
		return m.OldSemestername(ctx)
	}
	return nil, fmt.Errorf("unknown Semester field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SemesterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case semester.FieldSemestername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemestername(v)
		return nil
	}
	return fmt.Errorf("unknown Semester field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SemesterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SemesterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SemesterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Semester numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SemesterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SemesterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SemesterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Semester nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SemesterMutation) ResetField(name string) error {
	switch name {
	case semester.FieldSemestername:
		m.ResetSemestername()
		return nil
	}
	return fmt.Errorf("unknown Semester field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SemesterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._SemesterID != nil {
		edges = append(edges, semester.EdgeSemesterID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SemesterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case semester.EdgeSemesterID:
		ids := make([]ent.Value, 0, len(m._SemesterID))
		for id := range m._SemesterID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SemesterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_SemesterID != nil {
		edges = append(edges, semester.EdgeSemesterID)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SemesterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case semester.EdgeSemesterID:
		ids := make([]ent.Value, 0, len(m.removed_SemesterID))
		for id := range m.removed_SemesterID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SemesterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SemesterMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SemesterMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Semester unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SemesterMutation) ResetEdge(name string) error {
	switch name {
	case semester.EdgeSemesterID:
		m.ResetSemesterID()
		return nil
	}
	return fmt.Errorf("unknown Semester edge %s", name)
}

// StudyplanMutation represents an operation that mutate the Studyplans
// nodes in the graph.
type StudyplanMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_Studyplanname      *string
	clearedFields       map[string]struct{}
	_StudyplanID        map[int]struct{}
	removed_StudyplanID map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*Studyplan, error)
}

var _ ent.Mutation = (*StudyplanMutation)(nil)

// studyplanOption allows to manage the mutation configuration using functional options.
type studyplanOption func(*StudyplanMutation)

// newStudyplanMutation creates new mutation for $n.Name.
func newStudyplanMutation(c config, op Op, opts ...studyplanOption) *StudyplanMutation {
	m := &StudyplanMutation{
		config:        c,
		op:            op,
		typ:           TypeStudyplan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudyplanID sets the id field of the mutation.
func withStudyplanID(id int) studyplanOption {
	return func(m *StudyplanMutation) {
		var (
			err   error
			once  sync.Once
			value *Studyplan
		)
		m.oldValue = func(ctx context.Context) (*Studyplan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Studyplan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudyplan sets the old Studyplan of the mutation.
func withStudyplan(node *Studyplan) studyplanOption {
	return func(m *StudyplanMutation) {
		m.oldValue = func(context.Context) (*Studyplan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudyplanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudyplanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StudyplanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStudyplanname sets the Studyplanname field.
func (m *StudyplanMutation) SetStudyplanname(s string) {
	m._Studyplanname = &s
}

// Studyplanname returns the Studyplanname value in the mutation.
func (m *StudyplanMutation) Studyplanname() (r string, exists bool) {
	v := m._Studyplanname
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyplanname returns the old Studyplanname value of the Studyplan.
// If the Studyplan object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StudyplanMutation) OldStudyplanname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudyplanname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudyplanname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyplanname: %w", err)
	}
	return oldValue.Studyplanname, nil
}

// ResetStudyplanname reset all changes of the "Studyplanname" field.
func (m *StudyplanMutation) ResetStudyplanname() {
	m._Studyplanname = nil
}

// AddStudyplanIDIDs adds the StudyplanID edge to Scholarship by ids.
func (m *StudyplanMutation) AddStudyplanIDIDs(ids ...int) {
	if m._StudyplanID == nil {
		m._StudyplanID = make(map[int]struct{})
	}
	for i := range ids {
		m._StudyplanID[ids[i]] = struct{}{}
	}
}

// RemoveStudyplanIDIDs removes the StudyplanID edge to Scholarship by ids.
func (m *StudyplanMutation) RemoveStudyplanIDIDs(ids ...int) {
	if m.removed_StudyplanID == nil {
		m.removed_StudyplanID = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_StudyplanID[ids[i]] = struct{}{}
	}
}

// RemovedStudyplanID returns the removed ids of StudyplanID.
func (m *StudyplanMutation) RemovedStudyplanIDIDs() (ids []int) {
	for id := range m.removed_StudyplanID {
		ids = append(ids, id)
	}
	return
}

// StudyplanIDIDs returns the StudyplanID ids in the mutation.
func (m *StudyplanMutation) StudyplanIDIDs() (ids []int) {
	for id := range m._StudyplanID {
		ids = append(ids, id)
	}
	return
}

// ResetStudyplanID reset all changes of the "StudyplanID" edge.
func (m *StudyplanMutation) ResetStudyplanID() {
	m._StudyplanID = nil
	m.removed_StudyplanID = nil
}

// Op returns the operation name.
func (m *StudyplanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Studyplan).
func (m *StudyplanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StudyplanMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Studyplanname != nil {
		fields = append(fields, studyplan.FieldStudyplanname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StudyplanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case studyplan.FieldStudyplanname:
		return m.Studyplanname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StudyplanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case studyplan.FieldStudyplanname:
		return m.OldStudyplanname(ctx)
	}
	return nil, fmt.Errorf("unknown Studyplan field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StudyplanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case studyplan.FieldStudyplanname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyplanname(v)
		return nil
	}
	return fmt.Errorf("unknown Studyplan field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StudyplanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StudyplanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StudyplanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Studyplan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StudyplanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StudyplanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudyplanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Studyplan nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StudyplanMutation) ResetField(name string) error {
	switch name {
	case studyplan.FieldStudyplanname:
		m.ResetStudyplanname()
		return nil
	}
	return fmt.Errorf("unknown Studyplan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StudyplanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._StudyplanID != nil {
		edges = append(edges, studyplan.EdgeStudyplanID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StudyplanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case studyplan.EdgeStudyplanID:
		ids := make([]ent.Value, 0, len(m._StudyplanID))
		for id := range m._StudyplanID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StudyplanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_StudyplanID != nil {
		edges = append(edges, studyplan.EdgeStudyplanID)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StudyplanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case studyplan.EdgeStudyplanID:
		ids := make([]ent.Value, 0, len(m.removed_StudyplanID))
		for id := range m.removed_StudyplanID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StudyplanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StudyplanMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StudyplanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Studyplan unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StudyplanMutation) ResetEdge(name string) error {
	switch name {
	case studyplan.EdgeStudyplanID:
		m.ResetStudyplanID()
		return nil
	}
	return fmt.Errorf("unknown Studyplan edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Username      *string
	_Useremail     *string
	clearedFields  map[string]struct{}
	_UserID        map[int]struct{}
	removed_UserID map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the Username field.
func (m *UserMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the Username value in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old Username value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "Username" field.
func (m *UserMutation) ResetUsername() {
	m._Username = nil
}

// SetUseremail sets the Useremail field.
func (m *UserMutation) SetUseremail(s string) {
	m._Useremail = &s
}

// Useremail returns the Useremail value in the mutation.
func (m *UserMutation) Useremail() (r string, exists bool) {
	v := m._Useremail
	if v == nil {
		return
	}
	return *v, true
}

// OldUseremail returns the old Useremail value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUseremail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUseremail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUseremail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseremail: %w", err)
	}
	return oldValue.Useremail, nil
}

// ResetUseremail reset all changes of the "Useremail" field.
func (m *UserMutation) ResetUseremail() {
	m._Useremail = nil
}

// AddUserIDIDs adds the UserID edge to Scholarship by ids.
func (m *UserMutation) AddUserIDIDs(ids ...int) {
	if m._UserID == nil {
		m._UserID = make(map[int]struct{})
	}
	for i := range ids {
		m._UserID[ids[i]] = struct{}{}
	}
}

// RemoveUserIDIDs removes the UserID edge to Scholarship by ids.
func (m *UserMutation) RemoveUserIDIDs(ids ...int) {
	if m.removed_UserID == nil {
		m.removed_UserID = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_UserID[ids[i]] = struct{}{}
	}
}

// RemovedUserID returns the removed ids of UserID.
func (m *UserMutation) RemovedUserIDIDs() (ids []int) {
	for id := range m.removed_UserID {
		ids = append(ids, id)
	}
	return
}

// UserIDIDs returns the UserID ids in the mutation.
func (m *UserMutation) UserIDIDs() (ids []int) {
	for id := range m._UserID {
		ids = append(ids, id)
	}
	return
}

// ResetUserID reset all changes of the "UserID" edge.
func (m *UserMutation) ResetUserID() {
	m._UserID = nil
	m.removed_UserID = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m._Useremail != nil {
		fields = append(fields, user.FieldUseremail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldUseremail:
		return m.Useremail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldUseremail:
		return m.OldUseremail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldUseremail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseremail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldUseremail:
		m.ResetUseremail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._UserID != nil {
		edges = append(edges, user.EdgeUserID)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserID:
		ids := make([]ent.Value, 0, len(m._UserID))
		for id := range m._UserID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_UserID != nil {
		edges = append(edges, user.EdgeUserID)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserID:
		ids := make([]ent.Value, 0, len(m.removed_UserID))
		for id := range m.removed_UserID {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
